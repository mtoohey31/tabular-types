import TabularTypeInterpreter.Semantics.Type
import TabularTypeInterpreter.Syntax.InstanceEnvironment
import TabularTypeInterpreter.Syntax.Term

namespace TabularTypeInterpreter

open «F⊗⊕ω»

judgement_syntax Γᵢ "; " Γc "; " Γ " ⊢ " M " : " σ " ⇝ " E : Term.TypingAndElaboration

judgement_syntax Γᵢ "; " Γc "; " Γ " ⊨ " ψ " ⇝ " E : Monotype.ConstraintSolvingAndElaboration

mutual

judgement Term.TypingAndElaboration :=

x : σ ∈ Γ
───────────────────── var
Γᵢ; Γc; Γ ⊢ x : σ ⇝ x

∀ x ∉ I, Γᵢ; Γc; Γ, x : τ₀ ⊢ M^x : τ₁ ⇝ E^x
Γc; Γ ⊢ τ₀ : * ⇝ A
─────────────────────────────────────────── lam (I : List TermVarId)
Γᵢ; Γc; Γ ⊢ λ x. M : τ₀ → τ₁ ⇝ λ x : A. E

Γᵢ; Γc; Γ ⊢ M : τ₀ → τ₁ ⇝ F
Γᵢ; Γc; Γ ⊢ «N» : τ₀ ⇝ E
──────────────────────────── app
Γᵢ; Γc; Γ ⊢ M «N» : τ₁ ⇝ F E

Γc; Γ ⊢ ψ : C ⇝ A
∀ x ∉ I, Γᵢ; Γc; Γ, ψ ⇝ x ⊢ M^x : γ ⇝ E^x
───────────────────────────────────────── qualI (I : List TermVarId)
Γᵢ; Γc; Γ ⊢ M : ψ ⇒ γ ⇝ λ x : A. E

Γᵢ; Γc; Γ ⊨ ψ ⇝ E
Γᵢ; Γc; Γ ⊢ M : ψ ⇒ γ ⇝ F
───────────────────────── qualE
Γᵢ; Γc; Γ ⊢ M : γ ⇝ F E

∀ a ∉ I, Γᵢ; Γc; Γ, a : κ ⊢ M^a : σ^a ⇝ E^a
⊢ κ ⇝ K
─────────────────────────────────────────── schemeI (I : List TypeVarId)
Γᵢ; Γc; Γ ⊢ M : ∀ a : κ. σ ⇝ Λ a : K. E

Γᵢ; Γc; Γ ⊢ M : ∀ a : κ. σ ⇝ E
Γc; Γ ⊢ τ : κ ⇝ A
────────────────────────────── schemeE
Γᵢ; Γc; Γ ⊢ M : σ^^τ ⇝ E [A]

Γᵢ; Γc; Γ ⊢ M : σ₀ ⇝ E
Γc; Γ ⊢ σ₀ : * ⇝ A
∀ x ∉ I, Γᵢ; Γc; Γ, x : σ₀ ⊢ «N»^x : σ₁ ⇝ F^x
─────────────────────────────────────────────────────── «let» (I : List TermVarId)
Γᵢ; Γc; Γ ⊢ let x : σ₀ = M in «N» : σ₁ ⇝ ⦅λ x : A. F⦆ E

Γᵢ; Γc; Γ ⊢ M : σ ⇝ E
────────────────────────── annot
Γᵢ; Γc; Γ ⊢ M :' σ : σ ⇝ E

──────────────────────── label
Γᵢ; Γc; Γ ⊢ ℓ : ⌊ℓ⌋ ⇝ ()

Γᵢ; Γc; Γ ⊢ M : Π(μ) ⟨ξ ▹ τ⟩ ⇝ E
Γᵢ; Γc; Γ ⊢ «N» : ⌊ξ⌋ ⇝ F
──────────────────────────────── unlabelProd
Γᵢ; Γc; Γ ⊢ M/«N» : τ ⇝ π 0 E

Γᵢ; Γc; Γ ⊢ M : Σ(μ) ⟨ξ ▹ τ⟩ ⇝ E
Γᵢ; Γc; Γ ⊢ «N» : ⌊ξ⌋ ⇝ F
Γc; Γ ⊢ τ : * ⇝ A
───────────────────────────────────────────── unlabelSum
Γᵢ; Γc; Γ ⊢ M/«N» : τ ⇝ case E {λ x : A. x$0}

</ Γᵢ; Γc; Γ ⊢ M@i : ⌊ξ@i⌋ ⇝ F@i // i in [:n] />
</ Γᵢ; Γc; Γ ⊢ «N»@i : τ@i ⇝ E@i // i in [:n] />
───────────────────────────────────────────────────────────────────────────────────────────────────────────── prod
Γᵢ; Γc; Γ ⊢ {</ M@i ▹ «N»@i // i in [:n] />} : Π(μ) ⟨</ ξ@i ▹ τ@i // i in [:n] />⟩ ⇝ (</ E@i // i in [:n] />)

Γᵢ; Γc; Γ ⊢ M : ⌊ξ⌋ ⇝ F
Γᵢ; Γc; Γ ⊢ «N» : τ ⇝ E
──────────────────────────────────────────── sum
Γᵢ; Γc; Γ ⊢ [M ▹ «N»] : Σ(μ) ⟨ξ ▹ τ⟩ ⇝ ι 0 E

-- TODO: Figure out how to fix the equivalence problem here too.

Γᵢ; Γc; Γ ⊢ M : Π(μ) ρ₀ ⇝ E
Γᵢ; Γc; Γ ⊨ ρ₁ ≲(μ) ρ₀ ⇝ F
────────────────────────────────────────────────────── «prj»
Γᵢ; Γc; Γ ⊢ prj M : Π(μ) ρ₁ ⇝ ⦅π 0 F⦆ [λ a : *. a$0] E

Γᵢ; Γc; Γ ⊢ M : Π(μ) ρ₀ ⇝ E₀
Γᵢ; Γc; Γ ⊢ «N» : Π(μ) ρ₁ ⇝ E₁
Γᵢ; Γc; Γ ⊨ ρ₀ ⊙(μ) ρ₁ ~ ρ₂ ⇝ F
───────────────────────────────────────────────────────────── concat
Γᵢ; Γc; Γ ⊢ M ++ «N» : Π(μ) ρ₂ ⇝ ⦅π 0 F⦆ [λ a : *. a$0] E₀ E₁

Γᵢ; Γc; Γ ⊢ M : Σ(μ) ρ₀ ⇝ E
Γᵢ; Γc; Γ ⊨ ρ₀ ≲(μ) ρ₁ ⇝ F
────────────────────────────────────────────────────── «inj»
Γᵢ; Γc; Γ ⊢ inj M : Σ(μ) ρ₁ ⇝ ⦅π 1 F⦆ [λ a : *. a$0] E

Γᵢ; Γc; Γ ⊢ M : (Σ(μ) ρ₀) → τ ⇝ E₀
Γᵢ; Γc; Γ ⊢ «N» : (Σ(μ) ρ₁) → τ ⇝ E₁
Γᵢ; Γc; Γ ⊨ ρ₀ ⊙(μ) ρ₁ ~ ρ₂ ⇝ F
────────────────────────────────────────────────────────────────── elim
Γᵢ; Γc; Γ ⊢ M ▿ «N» : (Σ(μ) ρ₂) → τ ⇝ ⦅π 1 F⦆ [λ a : *. a$0] E₀ E₁

Γᵢ; Γc; Γ ⊢ M : τ₀ ⇝ E
Γc; Γ ⊢ τ₀ ≡ τ₁ ⇝ F
──────────────────────── equiv
Γᵢ; Γc; Γ ⊢ M : τ₁ ⇝ F E

Γᵢ; Γc; Γ ⊢ M : Ξ(N) ρ ⇝ E
────────────────────────── decay
Γᵢ; Γc; Γ ⊢ M : Ξ(μ) ρ ⇝ E

Γᵢ; Γc; Γ ⊢ M : Σ(μ) ⟨⟩ ⇝ E
────────────────────────────── never
Γᵢ; Γc; Γ ⊢ M : τ ⇝ case E { }

(</ TCₛ@i a ⇝ Aₛ@i // i in [:n] /> ⇒ TC a : κ) ↦ m : σ ⇝ A ∈ Γc
Γᵢ; Γc; Γ ⊨ TC τ ⇝ E
─────────────────────────────────────────────────────────────── member {TC}
Γᵢ; Γc; Γ ⊢ m : σ^^τ ⇝ π 0 E

Γᵢ; Γc; Γ ⊢ M : Ξ(C) ρ ⇝ E
────────────────────────────────── «order»
Γᵢ; Γc; Γ ⊢ order ρ M : Ξ(N) ρ ⇝ E

∀ a ∉ I₀, Γc; Γ ⊢ ρ : R κ ⇝ A
∀ a ∉ I₁, Γc; Γ, a : κ ⊢ τ^a : * ⇝ B^a
⊢ κ ⇝ K
Γᵢ; Γc; Γ ⊢ M : ∀ aₗ : L. ∀ aₜ : κ. ∀ aₚ : R κ. ∀ aᵢ : R κ. ∀ aₙ : R κ. ⟨aₗ$4 ▹ aₜ$3⟩ ⊙(N) aₚ$2 ~ aᵢ$1 ⇒ aₙ$0 ⊙(N) aᵢ$1 ~ ρ ⇒ ⌊aₗ$4⌋ → τ^^aₚ$2 → τ^^aᵢ$1 ⇝ E₀
Γᵢ; Γc; Γ ⊢ «N» : τ^^⟨⟩ ⇝ E₁
Γᵢ; Γc; Γ ⊨ Ind ρ ⇝ F
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── «ind» (I₀ I₁ : List TypeVarId)
Γᵢ; Γc; Γ ⊢ ind (λ a : R κ. τ) ρ; M; «N» : τ ⇝ F [λ a : L K. B] E₀ E₁

Γᵢ; Γc; Γ ⊢ M : Π(μ) ρ₂ ⇝ E
Γᵢ; Γc; Γ ⊨ Split (λ a : *. τ) ρ₀ ⊙' ρ₁ ~ ρ₂ ⇝ F
────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── «splitₚ»
Γᵢ; Γc; Γ ⊢ splitₚ (λ a : *. τ) M : Π(N) ⟨ℓₘ ▹ Π(μ) Lift (λ a : *. τ) ρ₀, ℓᵣ ▹ Π(μ) ρ₁⟩ ⇝ (⦅π 0 π 2 F⦆ [λ a : *. a$0] E, ⦅π 0 π 3 F⦆ [λ a : *. a$0] E)

Γᵢ; Γc; Γ ⊢ M : (Π(μ) (Lift (λ a : *. τ₀) ρ₀)) → τ₁ ⇝ E₀
Γᵢ; Γc; Γ ⊢ «N» : (Π(μ) ρ₁) → τ₁ ⇝ E₁
Γᵢ; Γc; Γ ⊨ Split (λ a : *. τ₀) ρ₀ ⊙' ρ₁ ~ ρ₂ ⇝ F
Γc; Γ ⊢ τ₁ : * ⇝ A
────────────────────────────────────────────────────────────────────────────────────────── «splitₛ»
Γᵢ; Γc; Γ ⊢ splitₛ (λ a : *. τ) M; «N» : (Π(μ) ρ₂) → τ₁ ⇝ ⦅π 1 F⦆ [λ a : *. a$0] [A] E₀ E₁

judgement Monotype.ConstraintSolvingAndElaboration :=

end

-- TODO: Put this somewhere.

variable (MfilterMap Mbind Mmap Msome : Term) (φOption φList : Monotype) (ℓₘ ℓᵣ : Label)

#check [[TabularTypeInterpreter.TypeScheme| ∀ aμ : U. ∀ aρ₀ : R *. ∀ aρ₁ : R *. ∀ aρ₂ : R *. ∀ aρ₃ : R *. Split (λ a : *. φOption a$0) aρ₀$3 ⊙' aρ₁$2 ~ aρ₂$1 ⇒ aρ₀$3 ⊙(aμ$4) aρ₁$2 ~ aρ₃$0 ⇒ (φList (Π(aμ$4) aρ₂$1)) → φList Π(aμ$4) aρ₃$0]]

#check [[TabularTypeInterpreter.Term| MfilterMap (λ xᵣ. let xₛ : ⟨ℓₘ ▹ Π(aμ$4) Lift (λ a : *. φOption a$0) aρ₀$3, ℓᵣ ▹ Π(aμ$4) aρ₁$2⟩ = splitₚ (λ a : *. φOption a$0) xᵣ$0 in ind (λ a : R *. φOption (Π(aμ$4) a$0)) aρ₀$3; (λ xₗ. λ xₐ. Mbind xₐ$0 λ xₐ. Mmap (prj xₛ$3/ℓₘ)/xₗ$2 λ x. {xₗ$3 ▹ x$0} ++ xₐ$1); (Msome {}) ++ xₛ$0/ℓᵣ)]]

end TabularTypeInterpreter
